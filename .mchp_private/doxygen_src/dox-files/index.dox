
/* List of DOT images to be generated for use in markup files but without being referenced in comments */
/*
//@dotfile pconfig.gv
//@dotfile flowchart.gv
*/

//First layer
/**
@defgroup firmware-flow Firmware Architecture

@brief Firmware Flowchart 
@details
<b>Firmware Task Scheduling</b><br><br>  
The SMPS Firmware Framework used in this application is organizing high and low priority tasks by a 
very simple task scheduler providing one common low-priority task level executed on priority level 
#0 and one high-priority task level executed on priority level #2. The interruption of processes on 
priority level #0 is enforced by a programmable timer. During system startup, the timer is set to 
overrun every 100 us, providing a stable high-priority task execution frequency of 10 kHz. 
All low-priority tasks are only allowed to run after all high-priority tasks have been completed. 
The real-time control system takes the highest priority within the firmware. This is ensured by 
using hardware triggers generated by the PWM signal generator logic with its high resolution time-base. 
The extremely short and optimized control loop code is implemented as monolithic Assembly routine to be 
most deterministic. Being triggered directly by the switching signal waveform generator, the execution 
is tightly coupled to the physical power conversion process and also independent from any other software 
process of the firmware.

@dotfile sfw_main.gv

*/

//Firmware Flowchart index
/**
@defgroup device-start-up Device Start Up
@ingroup firmware-flow
@dotfile dev-startup.gv
@brief Device Start Up
@details
 When the device comes out of RESET, it is running off the selected oscillator at its natural frequency.
 The startup oscillator type is declared in the FOSCSEL register by setting the respective configuration bits (FUSES).
 FUSES (configuration bits) can only be set at compile time before the settings are programmed into the device.
@code{.c} #pragma config FNOSC = FRCDIVN @endcode
 
 - <b>Step 1 (System Initialization):</b><br><br>
   The first step focuses on essential IC resources only, such as oscillator and device inputs/outputs.
   The following modules are initialized in the given order:<br><br>
   - <b>Main Oscillator: </b><br>
   In this design the internal 8 MHz RC oscillator is used. Hence, the very first step in the firmware is to set up 
   the internal PLL to operate the CPU at maximum speed of 100 MIPS (100 MHz instruction cycle).
   <br><br>
   - <b>Auxiliary Oscillator: </b><br>
   The Auxiliary Oscillator is a second PLL, which can be set up to a different frequency than the main oscillator and 
   provided to peripheral modules. This auxiliary clock signal is used by the PWM and ADC module to perform at maximum
   speed and performance. In this design, the auxiliary clock is set up for 500 MHz base clock. 
   <br><br>
   - <b>GPIO Reset: </b><br>
   To make sure there are no conflicts with individual application tasks and related peripheral configurations, all
   General Purpose Inputs/Outputs (GPIOs) are set as digital inputs with its internal control signals set LOW.
   <br><br>
   - <b>Digital Signal Processor Logic (DSP): </b><br>
   The internal Digital Signal Processing (DSP) engine is configured for fractional multiplication with saturation
   enabled. This configuration is optimized for control loop computations. The control loops are able to self-manage 
   their required DSP configuration, however, this would add execution cycles and increase the overall CPU load.
   As no other task/process in this application uses the DSP, the DSP configuration has been taken out of the 
   control loop CPU configuration self-management and added to the system initialization of the project as static 
   configuration to reduce the overall CPU workload.
   <br><br>

 - <b>Step 2 (User Peripheral Initialization):</b><br><br>
   The second step initializes user-defined peripherals, which are not managed by any other part of the application. 
   The following modules are initialized in the given order:<br><br>
   - <b>Digital-To-Analog Converter (DAC)</b><br>
     This design requires an independent reference voltage to adjust external current sense shunt amplifier devices to 
     offset their output voltage, allowing the monitoring of the full triangular inductor current waveform in discontinuous
     as well as continuous conduction mode. Each DAC module of dsPIC33 also includes an analog high-sped comparator, which 
     is not used in this configuration.
     <br><br>
   - <b>Operational Amplifier (OPA)</b><br>
     The internally generated reference voltage (see DAC configuration above) is buffered by using one of the on-chip Operational
     amplifiers. This section assigns the input pin to this op-amp and enables the output.
   <br><br>

 - <b>Step 3 (User Peripheral Initialization):</b><br><br>
   In the third step all tasks of the application are initialized by calling their default API INITIALIZE function. Each task
   module is self-managing and does not require additional parameters to be considered at this function call level. However, 
   each task provides an individual application layer which is used to configure the task and all its implied settings and 
   parameters. (Please refer to the documentation of each task for details.)<br><br>
   - <b>Power Control Task</b><br>
     The Power Control Task covers the complete management of the included power supply circuit and control loops.
     This tasks utilizes a standard single- and multiphase buck converter library, which provides a complete runtime 
     state-machine managing self-initialization, soft-start, soft-stop, runtime reference tuning and auto-restart.
     It also includes enhanced features such as automatic adjustment to pre-biased outputs, feedback offset compensation
     and supports different control modes such as voltage mode control (VMC) or average current mode control (ACMC).
   <br><br>
   - <b>Fault Monitor Task</b><br>
     The Fault Monitor Task is a global task providing application-wide fault detection. The separation of power converter 
     control and fault monitoring allows the consideration of application dependencies between tasks. 
   <br><br>

 - <b>Step 4 (OS Timer Initialization):</b><br><br>
   In the fourth step the operating system time base is initialized. In this slim application the operating system
   consists of two different task execution levels on two priority levels:
   <br><br>
   - <b>Low-Priority Task Execution</b><br>
   the low priority tasks are executed
   from a common function called @ref sysLowPriorityTasks_Execute. This task layer is executed with lowest priority (=0).
   <br><br>
   - <b>High-Priority Task Execution</b><br>
   High priority tasks are executed from the Timer Interrupt Service Routine (ISR) of the OS timebase timer. 
   The interupt priority is set one above the low priority task level (default = 2). In this application the 
   alternate working registers of the device have been configured to automatically switch context when the timer 
   interrupt is triggered by setting FUSE CTXT1 = IPL2.
   @code{.c} #pragma config CTXT1 = IPL2 @endcode

   <br><br>
   <br><br>

@defgroup main-loop Main Loop
@ingroup firmware-flow
@brief Main Loop 
@details
 

@defgroup main-loop-low-priority Low-Priority Task Execution
@ingroup main-loop
@brief Low priority task execution
 The execution of the sequence of low priority tasks is called from the main loop at lowest firmware priority #0.
 Tasks executed on this level may be interrupted by executions of high priority task sequences triggered by the 
 operating system timer interrupt as well as the real-time control sytem interrupts.  

@defgroup main-loop-high-priority High-Priority Task Execution
@ingroup main-loop
@brief High priority task execution
@details
 The execution of the sequence of high priority tasks is triggered by the operating system timer interrupt
 being called on the defined priority level (default = 2). The interrupt service routine utiilzes an alternate
 working register set for optimum coontext management. By default, alternate working register set #1 is reserved
 for high priority tasks.
*/

//Device Start-Up Sub-Index
/**
@defgroup system-initialization-mcu Initializing Essential Chip Resources
@ingroup device-start-up
@brief 
@details
 The initialization of essential chip resources includes main oscillator initialization, 
 GPIO reset and peripheral power management. All other chip resources are managed by each
 individual task or are initialized in the user peripehral initialization called after the
 essential chip resources have been configured.

@defgroup mcu-initialization Basic MCU Initialization
@ingroup system-initialization-mcu
@brief 
@details
 The initialization of all essential chip resources such as main oscillator, auxiliary clock
 for PWM, ADC and DAC. GPIO configuration, and the DSP core have been pulled together in
 on central SYSTEM_Initialize function, where function calls of each essentail chip resource
 can be executed in a specific sequence and be monitored for their successful completion.

@defgroup clock-initialization Main Oscillator Initialization
@ingroup system-initialization-mcu
@brief 
@details
 The main oscillator initialization configures the internal PLL to boost the user-defined 
 source clock to the desired operating frequency (e.g. 100 MHz for dsPIC33CK). 

@defgroup gpio-initialization Device Pin Configuration
@ingroup system-initialization-mcu
@brief 
@details
 When the device comes out of RESET, all general purpose inputs/outputs (GPIO) are configured
 as high-impedance inputs. Sample and hold (S&H) circuits of ADC inputs are active and digital
 functions are blocked. Depending on the application, this may or may not be desired. Hence,
 this routine is used to set a different default state at startup where GPIOs are high impedance
 inputs but all analog functions are disabled. 

@defgroup dsp-initialization Digital Signal Processor Configuration
@ingroup system-initialization-mcu
@brief 
@details
 The Digital Signal Processor (DSP) of dsPIC33C can be configured to support specific functions 
 optimized for fixed-point arithmetic of a normalized number space as well as enhanced features 
 such as accumulator and write-back saturation. As there is no other software instance using the 
 DSP other than the power supply control loops, the DSP is configured at device start to save 
 time during high frequency computations of the high-speed control loop.

@defgroup system-initialization-user-peripherals Initializing Hardware-Specific Chip Resources
@ingroup device-start-up
@brief 
@details
 This system initialization segment is reserved for user configurations, which are not covered 
 by standard library functions, such as circuit specific feedback signal conditioning or other
 independent functions.

@defgroup user-peripherals-initialization User Peripheral Initialization
@ingroup system-initialization-user-peripherals
@brief 
@details
 Some applications require specific peripheral module functions to implement functions, 
 which are not covered by user-task device driver modules, such as special logic functions 
 or additional analog components like operational amplifiers for signal conditioning. This 
 initialization routine can be used to add user-configurations to the project, which are 
 independent from device driver modules, These special peripheral modules are initialized 
 before the user tasks. Users will have to decide when and how these additional peripherals
 may be enabled to ensure no conflicts with user task device drivers occur.
*/

/* Application-specific hardware or microcontroller declarations */
/**
@defgroup dac-initialization Digital-to-Analog Converter
@ingroup system-initialization-user-peripherals
@brief 
@details
 DPSK3 uses one of the available on-chip Digital-to-Analog Converters (DAC) to generate 
 a dynamic, analog output signal, which can be used for enhanced debugging of high-speed
 processes such as control output monitoring.
@note
 The DAC output signal is buffered by utilizing one of the available on-chip operational
 amplifiers. Please refer to the Operational Amplifier Configuration section for details.
 
@defgroup op-amp-initialization Operational Amplifier Configuration
@ingroup system-initialization-user-peripherals
@brief 
@details
 As described in the Digital-to-Analog Converter (DAC) initialization section, DPSK3
 supports an internally generated, tunable, analog voltage signal for enhanced debugging.
 This DAC output signal is buffered by using one of the available on-chip operational amlifiers,
 which is configured and enabled in this section.
@note
 Please refer to the Digital-to-Analog (DAC) Configuration section for further details on
 the configuration of this peripheral.
*/

/**

@defgroup system-initialization-user-tasks Initializing Firmware Tasks
@ingroup device-start-up
@brief 
@details
 The application wide task execution requires a two step approach, where first the operating 
 system time base is configured and then all user-tasks are initialized. Once these two steps
 have been completed, the OS timer can be enabled and the main program will enter the main loop,
 continuously executing the specified and enabled user-tasks in high- and low-priority task
 execution sequences.
 
@defgroup os-timer-initialization Operating System Time Base
@ingroup system-initialization-user-tasks
@brief 
@details
 A simple 16-bit timer is used to generate the time base of the operating system. 
 This timer is set to overflow after the time period specified by @ref MAIN_EXECUTION_PERIOD 
 in the hardware abstraction layer. This time period is used to pace the high- and low priority
 task sequences of the main program. 
 
 Two public functions are provided to initialize the time base, configuring its desired period
 as well as setting up the interrupt priority of the high priority task sequence execution, and
 an ENABLE function, enabling the high priority task sequence execution interrupt. 
 
 Once the OS Timer and its interrupts are enabled, the main program will start to execute
 the user tasks with their respective priority and in their given order.
 
@defgroup user-task-initialization User Task Initialization
@ingroup system-initialization-user-tasks
@brief 
@details
 One function is used to initialize all high- and low-priority user tasks. Each task provides
 a dedicated, public initialization function initializing the main task data objects and 
 respective chip resources. At this stage, the tasks will be configured but not executed yet.
 The execution of the individual high- and low priority tasks will automatically be started
 once the operating system timer is initialized and enabled.

*/

// Hardware Abstraction Layer Title
/**
@defgroup abstraction-layer Hardware Abstraction Layer
@brief Hardware Abstraction Layer Declarations
@details
 The hardware abstraction layer introduces global defines which can be used in the firmware section of the source code to reference hardware dependent parameters and device peripheral instances and features.
 This abstraction is essential to adapt to hardware changes including migration across microcontroller device families and hardware versions with minimum risk and time efforts.
 As the microcontroller used in this design is a fixed, irreplaceable board component, this particular Hardware Abstraction Layer (HAL) covers declarations of circuit control and feedback signals as well as
 associated microcontroller peripheral instances and features.
*/

// Application Layer Sub-Index 
/**
@defgroup task-layer Application Layer
@brief Task Layer
@details
 The task layer covers all user tasks executed by the task scheduler. Each task is an independent entity 
 called on its respective priority level defined by the user. Tasks are proprietary user code modules 
 representing specific functions of the application or end-product. 


*/


// Library Layer
/**
@defgroup lib-layer Device Driver Library Layer 
@brief Generic Device Driver Layer
@details
  Device drivers are generic, comprehensive function libraries. Each library is widely self-contained
  and includes functional software routines and resource management functions. Because of their generic 
  nature, each library requires to be configured by proprietary user code to tailor their function to a 
  specific application. 

  Please refer to the specific device driver libraries for more information on public functions and
  properties provided to tailor and apply the supported features.

@defgroup lib-driver-layer Library Driver Layer 
@brief Generic Library Driver Layer
@details
  Library drivers are generic function libraries providing specific sub-functions for library modules. 
  Each library driver is widely self-contained and includes functional software routines and resource 
  management functions. Because of their generic nature, each library driver requires to be configured 
  by proprietary user code to tailor their function to a specific application. The settings required to 
  set up the library driver data objects are routed through the overlaying device driver, which also provides
  the API and public data objects holding the library driver settings.

  Please refer to the specific library driver for more information.

*/ 
